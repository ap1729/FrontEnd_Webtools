<!--NOTE: Every x,y coord has to be plotted as x(xactual),y(yactual) -->    
<!-- Line 768 to increase number of hexagons
var x = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
var y = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//900 is height value defined in SetSize()
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Level 1  + Backend</title>
    <!-- Bootstrap CSS -->
    <!--<link href="/css/bootstrap.min.css" rel="stylesheet">   when I do this tooltip vanishes-->

    <style type="text/css">

svg {
    border: none;
    background: white;
}

.bounds {
    stroke: red;
    fill: none;
}

.tile {
    stroke: black;
    stroke-width: 1px;
    fill: black;
    fill-opacity: 0.05;
}


.over {
    fill: black!important;  /* to show selected on hover*/    
    fill-opacity: 0.8 !important;
  }


div.tooltip {
    background: white;
    padding: 0px 2px;
    position: absolute;
    z-index: 10;
    visibility: hidden;
    font-size: 0.8em;
    font-family: sans-serif;
}

div.visible {
    visibility: visible !important;
}

    </style>
    <script type="text/javascript">
      var col1,node,x1,y1,m1,m2,table;    
      /// Global variables
      </script>
        <style>
 
   svgContainer {
  font: 10px sans-serif;
  shape-rendering: crispEdges;
   }
  rect {
  fill: #ddd;
  }
  .axis path,
 .axis line {
  fill: none;
  stroke: #fff;
  }
 
   </style>
  </head>
  <body>
   <h1 class="text-center">Graph</h1>
    <div class="panel panel-default">
      <div class="panel-body">
        <div class="well">
           <div id="drawbox"> 
          </div>
           <button type="button" class="btn btn-default" onclick="level0()">Level0</button>
           <button type="button" class="btn btn-default" onclick="level1()">Level1</button>
           View Top BS: <input type="checkbox" id="TopBS">
          <button type="button" class="btn btn-default" onclick="Reset()">Reset</button>
            No of BS <input id="TopBSno" type="number" step="1"> 
            Noise <input id="noise" type="number" step="0.01">  
            No.IC<input id="topx" type="number" step="c1">  
          </div>
          <form id="putdata">
                ROI <input id="LastSIR" type="number" step="0.01">   
                Pre SINR <input id="PreSINR" type="number" step="0.01"> 
                Post SINR <input id="PostSINR" type="number" step="0.01">              
              </form>
          <!--<button type="button" class="btn btn-default" onclick="">Level1</button> -->
     <!-- <button type="button" class="btn btn-default" onclick="loadMe()">Load Graphics</button>
      <button type="button" class="btn btn-default" >Plot Initial</button>  onclick="doPlot()"--> 
        </div>
      </div>
        <div>
           <div class="panel panel-default">
             <div class="panel-body">
              <p id="Output">
              <svg id="visual" width="1000" height="500"></svg>
                  Output
               
               </p>
             </div>
           </div>

        </div>


  <!-- jQuery -->
  <script src="js/jquery.js"></script>
  <!-- Bootstrap JavaScript -->
  <script src="/js/bootstrap.min.js"></script>
 <!-- <script src="//d3js.org/d3.v3.min.js"></script> -->  <!-- Needs internet -->
   <script type="text/javascript" src="/d3/d3.min.js"></script> 
  
  <script type="text/javascript">
  var xAxis,yAxis,tooltip;
  var xaxisobject,zoom;
 // var mycolormap = d3.scale.linear().domain([0 ,300]).range(["red", "green"]);

  var rows1=[],bs=[];//stores rows and bs data
  var oper=[];//array to store how many operators are there and how many Ue's in each,oper index starts from 0
  var bsno=[];//array to store how many bs for each operator
  var level=0;//which level it is currently in
  var topBsno=10;//no of Bs to show on click and in bar graph
  var opercolor=[{'color':"lime"},{'color':"orange"},{'color':"red"},{'color':"brown"},{'color':"yellow"}];//add as many as operators
  var bscolor=[{'color':"green"},{'color':"orange"},{'color':"red"},{'color':"brown"},{'color':"yellow"}];//add as many as operators
  var currselected; //latest selected circle
  var wcount=0;//window number
 // var BScord=[];//basestation coords 
  //var idtochange=""; // for dragging , unnecessary
  console.log(opercolor);
  

var x = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
var y = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//400 is height value defined in SetSize()

function SetSize(){
     margin = {top: 10, right: 10, bottom: 10, left: -20},
    width = 1200 //1200/to change dimensions of graph  seen///- margin.left - margin.right,
    height = 500 //500//- margin.top - margin.bottom;

  
  xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .ticks(0)
    .tickSize(-height);
  yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .ticks(0)
    .tickSize(-width);
zoom = d3.behavior.zoom()
    .x(x)
    .y(y)
    .scaleExtent([0.01,10000.00 ])   //this controls maximum zooming amount
    .center([x(1000), y(100)])
    .size([3000, 3000])
    .on("zoom", zoomed);
/*var drag = d3.behavior.drag()
    .origin(function(d) { return d; })
    .on("dragstart", dragstarted)
    .on("drag", dragged)
    .on("dragend", dragended);*/

tooltip = d3.select('body')
        .append('div')
        .classed('tooltip', true);

//for basestations
/*var drag1 = d3.behavior.drag()  
    .origin(function(d) { return d; })
    .on("dragstart", dragstarted1)
    .on("drag", dragged1)
    .on("dragend", dragended1);  */  
svg = d3.select("#drawbox").append("svg").attr("width", width+margin.left + margin.right).attr("height", height+margin.top + margin.bottom).attr("pointer-events",'all').call(zoom);;

svgContainer=svg.append("g").attr("id","svgContainer").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

xaxisobject=svgContainer.append("g")
    .attr("class", "x axis")
    .attr("transform",  function(d) {
       var event={translate: [0, 0], scale: 1} ||{};
      var translateX = event.translate[0] || 0,
          translateY = event.translate[1] || 0,
          scale = event.scale;
      return "translate("+translateX+","+translateY+")scale(" + scale + ")";
  })
    .call(xAxis);
svgContainer.append("g")
    .attr("class", "y axis")
    .call(yAxis);
 //window.alert()
d3.csv('Nodelocations.csv', 
        // accessor function
        function(d) {
            return {
                col1:d.col1,
                node:d.node,
                x:d.x,
                y:d.y,
                m1:d.m1,  
                m2:d.m2
                 };        } ,
       
        function (err, rows) {
          //console.log(rows);  
          var operno=1,ueno=0;//operator no and no of ue's for each operator 
          var operbsno=1,bsno1=0;//operator no and no of bs for each operator       
            var svg = d3.select("svg");
            var i=0;
            for(i=0;i<rows.length;i++) 
            {
              if(rows[i].node[0]=='B' && rows[i].node[1]=='S')
               {
                bs.push(rows[i]);//basestation
                
                 if(operbsno==rows[i].node[2])
                 {
                  bsno1++;
                 }
              else
               {
                   bsno.push({'operno':operbsno,'bsno':bsno1});
                   operbsno++;
                   bsno1=1;
                 }


               // BScord.push({x:rows[i].x,y:rows[i].y});
               }
              else
              {
                rows1.push(rows[i]);//operators
                //assuming UE's are in order
               if(operno==rows[i].node[2])
                 {
                  ueno++;
                 }
            else
               {
             oper.push({'operno':operno,'ueno':ueno});
              operno++;
               ueno=1;
               }

               // console.log(rows[i].col1);
              }
              //above function for seperating basestations and nodes,bs has basestations and rows1 has normal nodes
            
}       
oper.push({'operno':operno,'ueno':ueno});//for last operator
bsno.push({'operno':operbsno,'bsno':bsno1});//for last operator
//console.log(oper);
//console.log(bsno);
            console.log("UE",rows1);
            console.log("BS",bs);

          

            var circles = svgContainer.selectAll("circle").data(rows1).enter().append("circle");
            circles.attr("r", function(d,i) { return (3.5);}) 
            .attr("id",function(d,i){ 
           
              return "UE"+d.col1//original "UE"+d.node[2].toString()+"-"+d.col1

             })
            .attr("cx",function(d,i) { return x(d.x); })
            .attr("cy",function(d,i) { return y(d.y); })  
            .style("fill",function(d,i) { 
                                          return opercolor[parseInt(d.node[2])-1].color;
                                          } ) // to change colour of each basestation user 
           // .call(drag)
            .on('mouseover', mouseOver) 
            .on('mousemove', mouseMove)
            .on('mouseout', mouseOut)
            .on('mousedown', click);

           
            var rect= svgContainer.selectAll("rect").data(bs).enter().append("rect");
            rect.attr("x",function(d,i){ return x(d.x);})
            .attr("y",function(d,i){return y(d.y);})
            .attr("width",7)
            .attr("height",7)
            .style("fill",function(d,i) { 
                                        return bscolor[parseInt(d.node[2])-1].color;
                                        } ) 
            .attr("id",function(d,i){return "BS"+d.col1;})
            .on('mouseover', mouseOver1) ;
            // .call(drag1);*/
  
            //Origin , 0,0 ,temporary
            var rect1=svgContainer.append("rect");
             rect1.attr("x",x(0)).attr("y",y(0)).style("fill","blue").attr("width",7).attr("height",7);

            }
              
              );
}
// d3 mouse events
function mouseOver1(d,i){
  //function for basestation , mouse hover
    tooltip.text("BS" +(d.col1))   
       .classed('visible', true);
}
function mouseOver(d, i) {  
  //function for circle,tooltip on mouse hover

    d3.select(this).classed('over', true);
    if(level==0)
    { 
    tooltip.text("UE" +(d.col1))  
        .classed('visible', true);
      }
      else if(level==1)
      {
         var currop="";
         if(this.style.fill=='lime')
         {
           currop=1;//from definition
         }
      else if(this.style.fill=='orange')
         {
           currop=2;//from definition
         }
      else if(this.style.fill=='red')
         {
           currop=3;//from definition
         }
        else if(this.style.fill=='brown')
         {
           currop=4;//from definition
         }
        else if(this.style.fill=='yellow')
        {
         currop=5;
        }
        tooltip.text("UE" +(d.col1)+" Def:"+d.node[2]+" Curr:"+currop).classed('visible', true);
      }
      else
        console.log("Level undefined error");
}

function mouseMove(d, i) {
    tooltip.style('top', (d3.event.pageY - 20) + 'px')
        .style('left', (d3.event.pageX + 20) + 'px');
}

function mouseOut(d, i) {
    d3.select(this).classed('over', false);
    tooltip.classed('visible', false);
}

function onsuccess(obj){

console.log(obj); 
//obj.SIR is SIR
//obj.ROI is ROI
//obj.PrS is pre SINR
//obj.PoS is post SINR
//obj.Bsid is top x basestation id's

document.getElementById("LastSIR").value=obj.ROI;
document.getElementById("PostSINR").value=obj.PoS;
document.getElementById("PreSINR").value=obj.PrS;


if(document.getElementById("TopBS").checked == true)
{//button is also clicked, to enhance size of those basestations
  //console.log(barData[0].y);
  var Bsid="";
  for(i=0;i<bs.length;i++)
  {// to make all rect same size
    Bsid='#BS'+i.toString();
    d3.select(Bsid).attr("width",7).attr("height",7);
  }

  for(i=0;i<topBSno;i++) //top 10 ,hence this loop 
  {
   Bsid="#BS"+obj.Bsid[i].toString();
    d3.select(Bsid).attr("width",(125+obj.SIR[i]) ).attr("height",(125+obj.SIR[i]));// to change attributes of max basestations
  }
}//top rect being enlarged
 
 var barData=[];
  for(i=0;i<obj.Bsid.length;i++)
  {
    barData.push({'x':obj.Bsid[i],'y':obj.SIR[i]});
  }

PlotBarGraph(barData);

}



function click(d, i) { // on mouse click ,to be used for circles to show SINR profile ,modify it 
   //to send node info to backend and do appropriate calculations
   
topBSno=document.getElementById("TopBSno").value;
if(topBSno=="")
 topBSno=10;
else
  topBSno=parseInt(topBSno);
currselected=d.col1.toString()-bs.length;
BackObj={type:"A",node:parseInt(d.col1-bs.length),level:level,TopBSno:topBSno};//as d.col1 starts from no after basestation
console.log(JSON.stringify(BackObj));
$.post("http://localhost:8080/update",JSON.stringify(BackObj),onsuccess,"json");//getting from server

//above change the backend code and do parsing


wcount++;
newwindow();//plot on graph

    var element = d3.select(this),
        selected = element.classed('selected');
        
        element.classed('selected', !selected);
        d.type = selected ? 'regular' : 'selected';
        
        if(d.type=="selected")
          d3.select(this).attr("r",10);
        else
          d3.select(this).attr("r",3.5);
      }

function PlotBarGraph(barData){
  //function which plots bar graph
  //also increases top contributing basestations sizes 
InitChart(barData);

function InitChart(barData) {

d3.select("#BarGraph").remove();  
     
var key = function(d){
  return d.y;
}

//plotting
  vis = d3.select('#visual').append('svg').attr("id","BarGraph"),
    WIDTH = 500,//change width and height to change size of bar graph
    HEIGHT = 500,
    MARGINS = {
      top: 100,
      right: 20,
      bottom: 40,
      left: 50
    },
    xRange = d3.scale.ordinal().rangeRoundBands([MARGINS.left, WIDTH - MARGINS.right], 0.1).domain(barData.map(function (d) {
      return (d.x);
    })),


    yRange = d3.scale.linear().range([MARGINS.bottom,HEIGHT - MARGINS.top]).domain([0,d3.min(barData, function (d) {
        
        return d.y;
      })
    ]),

    xAxis = d3.svg.axis()
      .scale(xRange)
      .tickSize(5)
      .orient("top"),

    yAxis = d3.svg.axis()
      .scale(yRange)
      .tickSize(5)
      .orient("left");

/*console.log(barData.map(function (d) {
      return d.x;
    }))*/

 vis.append('svg:g')
    .attr('class', 'x axis')
    .attr('transform', 'translate(0,' + ( MARGINS.bottom) + ')')
    .call(xAxis);

  vis.append('svg:g')
    .attr('class', 'y axis')
    .attr('transform' ,'translate(' + (MARGINS.left) + ',0)')
    .call(yAxis);

        vis.selectAll("rect")
      .data(barData)
      .enter()
        .append('rect')
        .attr('class', function(d){return d.y < 0 ? "negative" : "positive";})
        .attr({
          x: function(d){
            return xRange(d.x);
          },
          y: function(d){
            return yRange(Math.max(0, d.y)); 
          },
          width: xRange.rangeBand(),
          height: function(d){
            return Math.abs(yRange(d.y) - yRange(0)); 
          }
          })
          .attr('fill','GRAY');
               
 }
}



function zoomed() {
  var translate = d3.event.translate,
            scale = d3.event.scale;
        svg.selectAll("circle").attr("transform", "translate(" + translate + ")scale(" + scale + ")");
        svg.selectAll("rect").attr("transform", "translate(" + translate + ")scale(" + scale + ")");
        svg.selectAll('.tile').attr("transform", "translate(" + translate + ")scale(" + scale + ")");
    }//above function causes zooming which is called in var zoom
    

function onsuccess1(obj)
{
 console.log(obj);
 /*
 var circles=svgContainer.selectAll("circle").data(obj.Changecolor)
      .style("fill",function(d){return opercolor[d].color; });//works but data shouldn't be changed
*/
//UE id starts from UE76
str1="#UE";
 for(i=0;i<obj.Changecolor.length;i++)
   {
    str2=str1+(i+76).toString();//UE id starts from UE76
    d3.select(str2).style("fill",opercolor[obj.Changecolor[i]].color);
   }

}


function level1()
{
level=1
console.log("BBBBBB",currselected);//row no 
BackObj={type:"B",node:13,level:level,TopBSno:topBsno};//as d.col1 starts from no after basestation
console.log(JSON.stringify(BackObj));
$.post("http://localhost:8080/update",JSON.stringify(BackObj),onsuccess1,"json");//getting from server
BackObj1={type:"A",node:currselected,level:level,TopBSno:topBSno};//as d.col1 starts from no after basestation
console.log(JSON.stringify(BackObj1));
$.post("http://localhost:8080/update",JSON.stringify(BackObj1),onsuccess,"json");//getting from server


}


function level0()
{ //level 0 reset
  level=0;
 var circles = svgContainer.selectAll("circle").data(rows1)
 .style("fill",function(d,i) { return opercolor[parseInt(d.node[2])-1].color;} ) ; 
 BackObj1={type:"A",node:currselected,level:level,TopBSno:topBSno};//as d.col1 starts from no after basestation
console.log(JSON.stringify(BackObj1));
$.post("http://localhost:8080/update",JSON.stringify(BackObj1),onsuccess,"json");//getting from server
}

function Reset()
{
  level0();
   svgContainer.selectAll("rect").attr("width",7).attr("height",7);
}






 


function loadMe(){
   SetSize();  

}
 






loadMe(); // This is the function that calls everything


//Hexagon creation here
var data = [];

(function() {
window.onload = function() {
    initialize();
};

var size =  1000/Math.sqrt(3), // hexagon size
    radius = 5, // number of hexagons in a row, to increase
    tilted = false; // true is horizontal alignment

var w = 4000, // width
    h = 0, // height,these two parameters are the ones to shift the hexagons
    padding = 50;

var translate = [0, 0];
 

function initialize() {
  
   tooltip = d3.select('body')
        .append('div')
        .classed('tooltip', true);

    fillMap();
    position();
    render();
}

function fillMap() {
    var id = 0,
        limit1 = 0,
        limit2 = radius;
    for (var j = -radius; j <= radius; j++) {
        var i = limit1;
        while (i <= limit2) {
          
            data.push({
                id: id++,
                coordinates: [i, j],

                type: 'regular',
               // resource: Math.random() < .005
            });
            i++;
        }
        if (j < 0) {
            limit1--;
        } else {
            limit2--;
        }
    }
}

function position() {
    //Note that stepX:stepY:offset ratio should be const
    var stepX = 1000,// Math.sqrt(3) * size / 2,
        stepY =  500*Math.sqrt(3),//size * 3 / 4 ,
        offset = 500//size / Math.sqrt(3) * 3 / 4
    data.map(function(d) {
        var i = d.coordinates[0],
            j = d.coordinates[1],
              x = stepX * i + (offset * j ) + w / 2 ,
              y = stepY * j  + h / 2;
        d.centroid = [Math.round(x * 1e2) / 1e2, Math.round(y * 1e2) / 1e2]; //centre of hexagon
        d.visible = 1;//visible everywhere
    });
}

function render() {
    renderMap();
}

function renderMap() {
    var grid = svgContainer.selectAll('polygon.tile')
        .data(getVisibleData(), function(d) { return d.id; });

    grid.enter()
        .sort(function(a, b) { return a.id - b.id; })
        .append('polygon')
        .classed('tile', true)
        .attr('points', function(d) {
            return hex(d.centroid, size, tilted).join(' '); //creates hexagon
        }) .style("pointer-events", "none").attr("transform", "translate(0," + 0 + ")");
 
 var x = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
var y = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//400 is height value defined in SetSize()

  grid.enter()
  .sort(function(a, b) { return a.id - b.id; })
  .append("circle")
   .attr("cx",function(d){ return x(d.centroid[0]); })
  .attr("cy",function(d){ return y(d.centroid[1]);})
  .attr("r", (40)) //radius of 200=40*5 m //linear scale of 5
  .style("fill","none")
  .style("stroke","blue")
  .attr('pointer-events', 'none');
 
  grid.exit().remove();
}



function move(x, y) {
    translate[0] += x;
    translate[1] += y;

    moveMap();
}

function moveMap() {
    var dx = translate[0],
        dy = translate[1];

    // Update data
    data.filter(function(d) {
        var x = d.centroid[0] + dx,
            y = d.centroid[1] + dy;
        return d.visible && outbounds(x, y);
    }).map(function(d) {
        d.visible = false;
        return d;
    });
    
    data.filter(function(d) {
        var x = d.centroid[0] + dx,
            y = d.centroid[1] + dy;
        return !d.visible && !outbounds(x, y);
    }).map(function(d) {
        d.visible = true;
        return d;
    });
    //
    
    renderMap();
    
    svg.selectAll('.tile')
        .attr('transform', 'translate(' + [dx, dy] + ')');
}

function outbounds(x, y) {
    return x < padding || x > w - padding || y < padding || y > h - padding;
}

function removeAll() {
    svg.selectAll('.tile').remove();
}

function hex(centroid) {
    var a = 1000/Math.sqrt(3),//size / 2, 
        b = 500,//(Math.sqrt(3) * a) / 2,
        x = centroid[0],
        y = centroid[1];
    var x1 = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
  var y1 = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//400 is height value defined in SetSize()
    //return  [[x - b, y - a / 2], [x - b, y + a / 2], [x, y + a], [x + b, y + a / 2], [x + b, y - a / 2], [x, y - a]];
        return [[x1(x - b),y1(y - a / 2)], [x1(x - b), y1(y + a/2)], [x1(x), y1(y + a)], [x1(x + b), y1(y + a / 2)], [x1(x + b), y1(y - a / 2)], [x1(x),y1(y - a)]];
}

function mouseScroll(d, i) {
    var e = d3.event,
        delta = e.wheelDelta ? e.wheelDelta : e.detail ? -e.detail : 0;
    if (delta > 0) {
        scrollUp();
    } else {
        scrollDown();
    }
    d3.event.preventDefault();
}
//

function scrollDown() {
    if (size > 20) {
        zoom(-20); // zoom out
    }
}

function scrollUp() {
    if (size < 80) {
        zoom(80); // zoom in
    }
}

function zoom(amount) {
    var proportion = (size + amount) / size,
        dx = translate[0] * proportion - translate[0],
        dy = translate[1] * proportion - translate[1];
    size += amount;
    removeAll();
    position();
    move(dx, dy);
}

function getVisibleData() { 
    return data.filter(function(d) { return d.visible; });
}

})();


function newwindow(){
  //function to open a new window and put graph
   //var myWindow = window.open("", "", "width=500,height=500");
   
 
  var embedded_svg = document.getElementById("visual");
  console.log(embedded_svg);
  var svg_win = window.open("", "svg_win"+wcount.toString(),"width=500,height=500");

  var transplanted_svg = svg_win.document.importNode(embedded_svg, true);
  var blank_root = svg_win.document.documentElement;
        svg_win.document.removeChild(blank_root);
        svg_win.document.appendChild(transplanted_svg);
         wcount++;
 //var svg_win = window.open("", "svg_win"+wcount.toString(),"width=500,height=500");
}



    </script>

  </body>
</html>