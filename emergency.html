<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Emergency</title>
    <!-- Bootstrap CSS -->

  <script src="/bower_components/jquery/dist/jquery.min.js" type="text/javascript" charset="utf-8" async defer></script>
    <link rel="stylesheet" href="/bower_components/bootstrap/dist/css/bootstrap.min.css">
    <script src="/bower_components/d3/d3.js" type="text/javascript" charset="utf-8" async defer></script>
    <script type="text/javascript" src="/js/jquery.js"></script>
      <script src="/js/bootstrap.min.js"></script>
      <script type="text/javascript" src="/bower_components/bootstrap/dist/js/bootstrap.js"></script>

<script type="text/javascript">
    $(function () {
        $("[rel='tooltip']").tooltip();
    });
</script>
 <style type="text/css">

svg {
    border: none;
    background: white;
}

.bounds {
    stroke: red;
    fill: none;
}

.ue {

  stroke: yellow;
  stroke-width: 0.6px;
}

.tile {
    stroke: black;
    stroke-width: 1px;
    fill: black;
    fill-opacity: 0.05;
}


.over {
    fill: black!important;  /* to show selected on hover*/
    fill-opacity: 0.8 !important;
  }

.inactive{
  fill: black!important;
  fill-opacity: 0.15;
}


div.visible {
    visibility: visible !important;
}

.loader {
    border: 16px solid #f3f3f3; /* Light grey */
    border-top: 16px solid #3498db; /* Blue */
    border-radius: 50%;
    position:absolute;
    top:400px;
    left:600px;
    width: 120px;
    height: 120px;
    display: none;
    animation: spin 2s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

           dt {
          width: 20px;
          height: 20px;
          display: inline-block;
          overflow: hidden;
          border: 1px solid #000;
          }
          .lime {background-color: lime; color: lime; }
          .orange {background-color: orange; color: orange; }
          .red {background-color: red; color: red; }
          .brown {background-color: brown; color: brown; }
          .circle{border-radius: 50%;}
          .rect1{}
          dd {
          display: inline-block;
          width: 7em;
          margin: 0 0 0 1em;
          }/* above is for legend*/

   svgContainer {
  font: 10px sans-serif;
  shape-rendering: crispEdges;
   }
  rect {
  fill: #ddd;
  }
  .axis path,
 .axis line {
  fill: none;
  stroke: #fff;
  }

   </style>
    </head>

  <body>

<nav class="navbar navbar-default " role="navigation">
  <div class="navbar navbar-inverse navbar-fixed-top">
    <div class="container-fluid" id="NavBar">
    </div>
  </div><!--- navigationbar-->
</nav>
<script src="NavBar.js"></script>


   <h1 class="text-center">Emergency Hexagonal Grid</h1>

    <div class="panel panel-default">

      <div class="panel-body">
        <div class="well">
           <div id="drawbox">
            <div class="loader" id="loader"></div>


           </div>
        </div>
      </div>
    </div>
      <!-- jQuery -->
  <script src="js/jquery.js"></script>
  <!-- Bootstrap JavaScript -->

 <!-- <script src="//d3js.org/d3.v3.min.js"></script> -->  <!-- Needs internet -->
   <script type="text/javascript" src="/d3/d3.min.js"></script>
  <script type="text/javascript" src="/bower_components/bootstrap/dist/js/bootstrap.js"></script>

<script type="text/javascript">
var x = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
var y = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//400 is height value defined in SetSize()

function SetSize(){
     margin = {top: 10, right: 10, bottom: 10, left: -20},
    width = 1400 //1200/to change dimensions of graph  seen///- margin.left - margin.right,
    height = 500 //500//- margin.top - margin.bottom;

var color = d3.scale.linear()
            .domain([-50,-30,-20,-10]) //domain of value  corresponding to colour
            .range(['black','red','blue','green']);//colour to go change value

  xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .ticks(0)
    .tickSize(-height);
  yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .ticks(0)
    .tickSize(-width);
zoom = d3.behavior.zoom()
    .x(x)
    .y(y)
    .scaleExtent([0.01,10000.00 ])   //this controls maximum zooming amount
    .center([x(1000), y(100)])
    .size([3000, 3000])
    .on("zoom", zoomed);
    /*
var drag = d3.behavior.drag()
    .origin(function(d) { return d; })
    .on("dragstart", dragstarted)
    .on("drag", dragged)
    .on("dragend", dragended);*/
    svg = d3.select("#drawbox").append("svg").attr("width", width+margin.left + margin.right).attr("height", height+margin.top + margin.bottom).attr("pointer-events",'all').call(zoom);;
svgContainer=svg.append("g").attr("id","svgContainer").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

xaxisobject=svgContainer.append("g")
    .attr("class", "x axis")
    .attr("transform",  function(d) {
       var event={translate: [0, 0], scale: 1} ||{};
      var translateX = event.translate[0] || 0,
          translateY = event.translate[1] || 0,
          scale = event.scale;
      return "translate("+translateX+","+translateY+")scale(" + scale + ")";
  })
    .call(xAxis);
svgContainer.append("g")
    .attr("class", "y axis")
    .call(yAxis);


d3.csv('/data/emergency.csv',//Sectorlocations.csv'
        // accessor function
        function(d) {
            return {
                X:d.X,
                Y:d.Y,
                RxPow:d.RxPow
                 };        } ,
                 function (err, rows) {
                 if(err!=null)
                  {console.log("Error Data not loaded");}
                   console.log(rows);
                    var svg = d3.select("svg");
                    var i=0;

                 var circles = svgContainer.selectAll("circle").data(rows).enter().append("circle");
            circles.attr("r", function(d,i) { return (3.5);})
           /* .attr("id",function(d,i){

              return "UE"+d.col1//original "UE"+d.node[2].toString()+"-"+d.col1

             })*/
          .attr("class","ue")
            .attr("cx",function(d,i) { return x(d.X); })
            .attr("cy",function(d,i) { return y(d.Y); })
            .style("fill",function(d,i) { //return "blue";
                                          return color(d.RxPow);
                                         // return opercolor[parseInt(d.node[2])-1].color;
                                          } )

                 });

}
SetSize();






function zoomed() {
  //does pan +zoom
    //console.log("Normal",d3.mouse(this),window.event);
  var translate = d3.event.translate,
            scale = d3.event.scale;
        svg.selectAll("circle").attr("transform", "translate(" + translate + ")scale(" + scale + ")");
        svg.selectAll("rect").attr("transform", "translate(" + translate + ")scale(" + scale + ")");
        svg.selectAll('.tile').attr("transform", "translate(" + translate + ")scale(" + scale + ")");
  }//above function causes zooming which is called in var zoom



//Hexagon creation here
var data = [];

(function() {
window.onload = function() {
    initialize();
};

var size =  1000/Math.sqrt(3), // hexagon size
    radius = 5, // number of hexagons in a row, to increase
    tilted = false; // true is horizontal alignment

var w = 4000, // width
    h = 0, // height,these two parameters are the ones to shift the hexagons
    padding = 50;

var translate = [0, 0];


function initialize() {
      fillMap();
    position();
    render();
}

function fillMap() {
    var id = 0,
        limit1 = 0,
        limit2 = radius;
    for (var j = -radius; j <= radius; j++) {
        var i = limit1;
        while (i <= limit2) {

            data.push({
                id: id++,
                coordinates: [i-2, j],  //i-2 to centralise hexagons

                type: 'regular',
               // resource: Math.random() < .005
            });
            i++;
        }
        if (j < 0) {
            limit1--;
        } else {
            limit2--;
        }
    }
}

function position() {
    //Note that stepX:stepY:offset ratio should be const
    var stepX = 1000,// Math.sqrt(3) * size / 2,
        stepY =  500*Math.sqrt(3),//size * 3 / 4 ,
        offset = 500//size / Math.sqrt(3) * 3 / 4
    data.map(function(d) {
        var i = d.coordinates[0],
            j = d.coordinates[1],
              x = stepX * i + (offset * j ) + w / 2 ,
              y = stepY * j  + h / 2;
  //            console.log("AAA",x,y);
        d.centroid = [Math.round(x * 1e2) / 1e2, Math.round(y * 1e2) / 1e2]; //centre of hexagon
        d.visible = 1;//visible everywhere
    });
}

function render() {
    renderMap();
}

function renderMap() {
    var grid = svgContainer.selectAll('polygon.tile')
        .data(getVisibleData(), function(d) { return d.id; });

    grid.enter()
        .sort(function(a, b) { return a.id - b.id; })
        .append('polygon')
        .classed('tile', true)
        .attr('points', function(d) {
            return hex(d.centroid, size, tilted).join(' '); //creates hexagon
        }) .style("pointer-events", "none").attr("transform", "translate(0," + 0 + ")");

 var x = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
var y = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//400 is height value defined in SetSize()

  grid.enter()
  .sort(function(a, b) { return a.id - b.id; })
  .append("circle")
   .attr("cx",function(d){ return x(d.centroid[0]); })
  .attr("cy",function(d){ return y(d.centroid[1]);})
  .attr("r", (40)) //radius of 200=40*5 m //linear scale of 5
  .style("fill","none")
  .style("stroke","blue")
  .attr('pointer-events', 'none');

  grid.exit().remove();
}



function move(x, y) {
    translate[0] += x;
    translate[1] += y;

    moveMap();
}

function moveMap() {
    var dx = translate[0],
        dy = translate[1];

    // Update data
    data.filter(function(d) {
        var x = d.centroid[0] + dx,
            y = d.centroid[1] + dy;
        return d.visible && outbounds(x, y);
    }).map(function(d) {
        d.visible = false;
        return d;
    });

    data.filter(function(d) {
        var x = d.centroid[0] + dx,
            y = d.centroid[1] + dy;
        return !d.visible && !outbounds(x, y);
    }).map(function(d) {
        d.visible = true;
        return d;
    });
    //

    renderMap();

    svg.selectAll('.tile')
        .attr('transform', 'translate(' + [dx, dy] + ')');
}

function outbounds(x, y) {
    return x < padding || x > w - padding || y < padding || y > h - padding;
}

function removeAll() {
    svg.selectAll('.tile').remove();
}

function hex(centroid) {
    var a = 1000/Math.sqrt(3),//size / 2,
        b = 500,//(Math.sqrt(3) * a) / 2,
        x = centroid[0],
        y = centroid[1];
    var x1 = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
  var y1 = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//400 is height value defined in SetSize()
    //return  [[x - b, y - a / 2], [x - b, y + a / 2], [x, y + a], [x + b, y + a / 2], [x + b, y - a / 2], [x, y - a]];
        return [[x1(x - b),y1(y - a / 2)], [x1(x - b), y1(y + a/2)], [x1(x), y1(y + a)], [x1(x + b), y1(y + a / 2)], [x1(x + b), y1(y - a / 2)], [x1(x),y1(y - a)]];
}

function mouseScroll(d, i) {
    var e = d3.event,
        delta = e.wheelDelta ? e.wheelDelta : e.detail ? -e.detail : 0;
    if (delta > 0) {
        scrollUp();
    } else {
        scrollDown();
    }
    d3.event.preventDefault();
}
//

function scrollDown() {
    if (size > 20) {
        zoom(-20); // zoom out
    }
}

function scrollUp() {
    if (size < 80) {
        zoom(80); // zoom in
    }
}

function zoom(amount) {
    var proportion = (size + amount) / size,
        dx = translate[0] * proportion - translate[0],
        dy = translate[1] * proportion - translate[1];
    size += amount;
    removeAll();
    position();
    move(dx, dy);
}

function getVisibleData() {
    return data.filter(function(d) { return d.visible; });
}

})();

</script>

</body>
  </html>
