<!--NOTE: Every x,y coord has to be plotted as x(xactual),y(yactual) -->    
<!--
var x = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
var y = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//900 is height value defined in SetSize()
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Hexagons Test</title>
   <!-- <script type="text/javascript" src="http://mbostock.github.com/d3/d3.min.js?1.29.6"></script>
    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.behavior.min.js?1.29.6"></script>-->   
    <script type="text/javascript" src="/d3/d3.min.js"></script> 
    <style type="text/css">
svg {
    border: none;
    background: white;
}

.bounds {
    stroke: red;
    fill: none;
}

.tile {
    stroke: black;
    stroke-width: 1px;
    fill: black;
    fill-opacity: 0.05;
}


.over {
    fill: orange!important;
    fill-opacity: 0.8 !important;
}


div.tooltip {
    background: white;
    padding: 0px 2px;
    position: absolute;
    z-index: 10;
    visibility: hidden;
    font-size: 0.8em;
    font-family: sans-serif;
}

div.visible {
    visibility: visible !important;
}

    </style>
    <script type="text/javascript">
      var col1,node,x1,y1,m1,m2,table;    
      /// Global variables
      </script>
        <style>
 
   svgContainer {
  font: 10px sans-serif;
  shape-rendering: crispEdges;
   }
  rect {
  fill: #ddd;
  }
  .axis path,
 .axis line {
  fill: none;
  stroke: #fff;
  }
 
   </style>
  </head>
  <body>
   <h1 class="text-center">Graph</h1>
    <div class="panel panel-default">
      <div class="panel-body">
        <div class="well">
           <div id="drawbox"> </div>
          </div>
     <!-- <button type="button" class="btn btn-default" onclick="loadMe()">Load Graphics</button>
      <button type="button" class="btn btn-default" >Plot Initial</button>  onclick="doPlot()"--> 
        </div>
      </div>
        <div>
           <div class="panel panel-default">
             <div class="panel-body">
              <p id="Output">
              <svg id="visual" width="1000" height="500"></svg>
                  Output
            
               </p>
             </div>
           </div>

        </div>

        <!--
        <div>
           <div class="panel panel-default">
             <div class="panel-body">
              <form id="putdata">
                Xaxis <input type="number" step="0.0000000001">
                Yaxis<input type="number" step="0.0000000001">
                Size<input type="number" step="0.0000000001">
                Colour<input type="number" step="0.0000000001">
              </form>
              <p id="Form2Output">No circle has been clicked yet</p>
               <button type="button" class="btn btn-default" onclick="Addchange()">Make Changes and Plot</button>
                
                 <button type="button" class="btn btn-default" onclick="ResetChange()">ReSet Changes</button> 
             </div>
           </div>
        </div>
      -->   
           
      

  <!-- jQuery -->
  <script src="js/jquery.js"></script>
  <!-- Bootstrap JavaScript -->
  <script src="/js/bootstrap.min.js"></script>
 <!-- <script src="//d3js.org/d3.v3.min.js"></script> -->  <!-- Needs internet -->
   <script type="text/javascript" src="/d3/d3.min.js"></script> 
  
  <script type="text/javascript">
  var xAxis,yAxis,tooltip;
  var xaxisobject,zoom;
  var mycolormap = d3.scale.linear().domain([0 ,300]).range(["red", "green"]);
  var idtochange="";
  var BScord=[];//basestation coords ,plan is to take this directly from first couple of rows of csv file ,Id =0, and marke them with rectangle or something
var x = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
var y = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//400 is height value defined in SetSize()


function SetSize(){
     margin = {top: 10, right: 10, bottom: 10, left: -20},
    width = 1200 //- margin.left - margin.right,
    height = 500 //- margin.top - margin.bottom;

  
  xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .ticks(0)
    .tickSize(-height);
  yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .ticks(0)
    .tickSize(-width);
zoom = d3.behavior.zoom()
    .x(x)
    .y(y)
    .scaleExtent([0.01,10000.00 ])   //this controls maximum zooming amount
    .center([x(1000), y(100)])
    .size([3000, 3000])
    .on("zoom", zoomed);
var drag = d3.behavior.drag()
    .origin(function(d) { return d; })
    .on("dragstart", dragstarted)
    .on("drag", dragged)
    .on("dragend", dragended);

tooltip = d3.select('body')
        .append('div')
        .classed('tooltip', true);

//for basestations
var drag1 = d3.behavior.drag()  
    .origin(function(d) { return d; })
    .on("dragstart", dragstarted1)
    .on("drag", dragged1)
    .on("dragend", dragended1);    
svg = d3.select("#drawbox").append("svg").attr("width", width+margin.left + margin.right).attr("height", height+margin.top + margin.bottom).attr("pointer-events",'all').call(zoom);;

svgContainer=svg.append("g").attr("id","svgContainer").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

 visual=d3.select("#drawbox").append("svg").attr("width",200).attr("height",200);
    //var cgroup = svg.append("g"); 

//d3.select("#drawbox").append("svg").id("visual").width("200").height("300");

/*
    svg.append("rect")
    .attr("width", 5000)
    .attr("height", 4000)
    .attr('pointer-events', 'all');
    */
  

xaxisobject=svgContainer.append("g")
    .attr("class", "x axis")
    .attr("transform",  function(d) {
       var event={translate: [0, 0], scale: 1} ||{};
      var translateX = event.translate[0] || 0,
          translateY = event.translate[1] || 0,
          scale = event.scale;
      return "translate("+translateX+","+translateY+")scale(" + scale + ")";
  })
    .call(xAxis);
svgContainer.append("g")
    .attr("class", "y axis")
    .call(yAxis);
 //window.alert()
d3.csv('Nodelocations1.csv', 
        // accessor function
        function(d) {
            return {
                col1:d.col1,
                node:d.node,
                x:d.x,
                y:d.y,
                m1:d.m1,  
                m2:d.m2
                 };        } ,
       
        function (err, rows) {
          console.log(rows);
          var rows1=[],bs=[];
            var svg = d3.select("svg");
            var i=0;
            for(i=0;i<rows.length;i++)
            {
              if(rows[i].node[0]=='B' && rows[i].node[1]=='S')
               {
                bs.push(rows[i]);
                BScord.push({x:rows[i].x,y:rows[i].y});
               }
              else
                rows1.push(rows[i]);
              //above function for seperating basestations and nodes,bs has basestations and rows1 has normal nodes
            
}            console.log(BScord);
            var circles = svgContainer.selectAll("circle").data(rows1).enter().append("circle");
            // Now work on updating the circles based on the data
            circles.attr("r", function(d,i) { return (3.5);})  //window.alert(d.x);window.alert(d.y);window.alert(d.m1);window.alert(d.m2);window.alert(d.node);window.alert(d.col1);
            .attr("id",function(d,i){ 
              //need to change ,id is ERROR
               if(d.node==1) 
                 return "node1  "+d.col1;
               else if(d.node==2)
                  return "node2  "+d.col1;
                else if(d.node==0)
                  return "BaseStation "+d.col1;
                else
                   return "ERROR";
             })
            .attr("cx",function(d,i) { return x(d.x); })
            .attr("cy",function(d,i) { return y(d.y); })  
            .style("fill",function(d,i) { if(d.node[2]=='1') return "lime";//for UE1
                                         else if(d.node[2]=='2') return "orange";//for UE2
                                        else if(d.node[2]=='3') return "red";//for UE3
                                         else if(d.node[2]=='4') return "yellow";//for UE4
                                          else return "blue";} ) // to change colour of each basestation user 
           // .call(drag)
            .on('mouseover', mouseOver) 
            .on('mousemove', mouseMove)
            .on('mouseout', mouseOut)
            .on('mousedown', click);
            
            var rect= svgContainer.selectAll("rect").data(bs).enter().append("rect");
            rect.attr("x",function(d,i){ return x(d.x);})
            .attr("y",function(d,i){return y(d.y);})
            .attr("width",7)
            .attr("height",7)
            .style("fill",function(d,i) { if(d.node[2]=='1') return "green";//for BS1
                                         else if(d.node[2]=='2') return "orange";//for BS2
                                        else if(d.node[2]=='3') return "red";//for Bs3
                                         else if(d.node[2]=='4') return "yellow";//for BS4
                                          else return "blue";} ) 
            .attr("id",function(d,i){return "BaseStation "+d.col1;})
            .on('mouseover', mouseOver1) ;
            // .call(drag1);
 
            //Origin , 0,0 ,temporary
            var rect1=svgContainer.append("rect");
             rect1.attr("x",x(0)).attr("y",y(0)).style("fill","blue").attr("width",7).attr("height",7);
             


            }
              
              );
}
// d3 mouse events
function mouseOver1(d,i){
  //function for basestation , mouse hover
   //d3.select(this).classed('over', true);
    //window.alert();
    tooltip.text('('+parseFloat(d.x).toFixed(1)+","+parseFloat(d.y).toFixed(1)+')'+" " +(d.m1))  //d.id+ ' (' + d.coordinates + ')  ' + d.lastSelected  
       .classed('visible', true);
}
function mouseOver(d, i) { //tooltip to be used for circles 
  //function for circle, mouse hover
    d3.select(this).classed('over', true);
    tooltip.text('('+parseFloat(d.x).toFixed(1)+","+parseFloat(d.y).toFixed(1)+')'+" " +(d.m1))  //d.id+ ' (' + d.coordinates + ')  ' + d.lastSelected  
        .classed('visible', true);
    PlotBarGraph();//to plot bar graph for SIR profile
}


function PlotBarGraph(){
  InitChart();

function gettopthree(arrayData){  //sorting to top 3 function
//  arrayData.sort(function(a, b) {
//         return parseFloat(b.value) - parseFloat(a.value);
//         return d3.descending((b.value), (a.value));
//                });
 //return arrayData.slice(0); 

arrayData.sort(function(a,b){
  if(a.y < b.y){
    return 1;
  }
  if(a.y > b.y){
    return -1;
  }
  return 0;
});
return arrayData.slice(0,5);
}

function InitChart() {

  var barData = [{  'x': 1,'y': 5}, {'x': 12,  'y': 29}, {'x': 6,'y': 12}, {'x': 7,'y': 91}, {'x': 2,'y': 37}, {'x': 8,'y': 160},{'x': 11,'y': 15}, {'x': 3,'y': 210}, {'x': 9,'y': 116}, {'x': 4,'y': 43}, {'x': 10,'y': 5}, {'x': 5,'y': 60}];
  

barData = gettopthree(barData);
  var vis = d3.select("#visual"),
    WIDTH = 700,
    HEIGHT = 300,
    MARGINS = {
      top: 20,
      right: 20,
      bottom: 20,
      left: 50
    },
    xRange = d3.scale.ordinal().rangeRoundBands([MARGINS.left, WIDTH - MARGINS.right], 0.1).domain(barData.map(function (d) {
      return d.x;
    }))


    yRange = d3.scale.linear().range([HEIGHT - MARGINS.top, MARGINS.bottom]).domain([0,
      d3.max(barData, function (d) {
        return d.y;
      })
    ]),

    xAxis = d3.svg.axis()
      .scale(xRange)
      .tickSize(5),

    yAxis = d3.svg.axis()
      .scale(yRange)
      .tickSize(5)
      .orient("left");


  vis.append('svg:g')
    .attr('class', 'x axis')
    .attr('transform', 'translate(0,' + (HEIGHT - MARGINS.bottom) + ')')
    .call(xAxis);

  vis.append('svg:g')
    .attr('class', 'y axis')
    .attr('transform', 'translate(' + (MARGINS.left) + ',0)')
    .call(yAxis);


  vis.selectAll('rect')
    .data(barData)
    .enter()
    .append('rect')
    .attr('x', function (d) {
      return xRange(d.x);
    })
    .attr('y', function (d) {
      return yRange(d.y);
    })
    .attr('width', xRange.rangeBand())
    .attr('height', function (d) {
      return ((HEIGHT - MARGINS.bottom) - yRange(d.y));
    })
    .attr('fill', 'grey');



}
}








function mouseMove(d, i) {
    tooltip.style('top', (d3.event.pageY - 20) + 'px')
        .style('left', (d3.event.pageX + 20) + 'px');
}

function mouseOut(d, i) {
    d3.select(this).classed('over', false);
    tooltip.classed('visible', false);
}

function click(d, i) { // on mouse click ,to be used for circles to show SINR profile ,modify it 
    var element = d3.select(this),
        selected = element.classed('selected');
        
        element.classed('selected', !selected);
        d.type = selected ? 'regular' : 'selected';
        d.lastSelected = +d3.event.timeStamp;
        
        //tooltip.text(d.id + ' (' + d.coordinates + ') / ' + d.lastSelected);
}
function zoomed() {
  // svg.select(".x.axis").call(xAxis);
  // svg.select(".y.axis").call(yAxis); //above two causes fixed axis
  
//
  var translate = d3.event.translate,
            scale = d3.event.scale;
      //  translate[0] = Math.max(-600*scale, Math.min(600*scale, translate[0]));
      // translate[1] = Math.max(-600*scale, Math.min(600*scale, translate[1]));

        svg.selectAll("circle").attr("transform", "translate(" + translate + ")scale(" + scale + ")");
        svg.selectAll("rect").attr("transform", "translate(" + translate + ")scale(" + scale + ")");
        svg.selectAll('.tile').attr("transform", "translate(" + translate + ")scale(" + scale + ")");
        //
  
  //svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
 
    
  //svgContainer.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
  //above line causes movement also
  
    }//above function causes zooming which is called in var zoom
    
function dragstarted(d) {
  d3.event.sourceEvent.stopPropagation();
  d3.select(this).classed("dragging", true);
  console.log(d,d3.event);
var x = d3.scale.linear()
    .domain([-5, (30 )]) // changes range of values for x axis
    .range([0, width]);
var y = d3.scale.linear()
    .domain([-5, 30 ]) // changes range of values for y axis
    .range([height, 0]);
d.x=x.invert(d3.event.sourceEvent.offsetX);
d.y=y.invert(d3.event.sourceEvent.offsetY);
console.log(d3.event);
 d3.select(this).attr("cx", x(d.x)).attr("cy", y(d.y));
}
function dragged(d) {
 
  //  d.x=d3.event.sourceEvent.offsetX;
//d.y=d3.event.sourceEvent.offsetY;
//if(d3.event.sourceEvent.offsetX>20  && d3.event.sourceEvent.offsetY>20)  ///to prevent stuckat dragging

d.x=x.invert(d3.event.sourceEvent.offsetX);
d.y=y.invert(d3.event.sourceEvent.offsetY);
//d.x=d3.event.sourceEvent.clientX;//try putting -35 here
//d.y=d3.event.sourceEvent.clientY;
 console.log(d3.event.sourceEvent.offsetX);
 d3.select(this).attr("cx", x(d.x)).attr("cy", y(d.y));
 
 // d3.select(this).attr("cx", d[0] = d3.event.sourceEvent.x)
               //.attr("cy", d[1] = d3.event.sourceEvent.y);
// d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
     //  d.x += d3.event.dx;
      //      d.y += d3.event.dy;
            // d3.select(this).attr("transform", function(d,i){
            //     return "translate(" + [d3.event.dx,d3.event.dy ] + ")"});
}
function dragended(d) {
     console.log(d,"ended ",d3.event,this);
 d3.select(this).classed("dragging", false);
  var x = d3.scale.linear()
    .domain([-5, (30 )]) // changes range of values for x axis
    .range([0, width]);
var y = d3.scale.linear()
    .domain([-5, 30 ]) // changes range of values for y axis
    .range([height, 0]);
console.log('Am I at ', x.invert(d.x),y.invert(d.y)) ;
//console.log('But actually at',d.x,d.y,x(d.x),y(d.y));
//Backend Part here

BackObj={node:parseInt(d.node),Col:parseInt(d.col1),Column1:parseFloat(d.x),Column2:parseFloat(d.y),Column3:parseFloat(d.m1),Column4:parseFloat(d.m2)};//,x1:parseFloat(BScord[0].x),y1:parseFloat(BScord[0].y),x2:parseFloat(BScord[1].x),y2:parseFloat(BScord[1].y)};//Creating object to send to backend
                if(d.node==1) 
                 idtochange = "node1  "+d.col1;
               else if(d.node==2)
                  idtochange = "node2  "+d.col1;
              else
                  idtochange = "ERROR";
//window.alert(idtochange);

$.post("http://localhost:8080/update",JSON.stringify(BackObj),onsuccess,"json");//getting from server
             
}
 
function onsuccess(obj) {
 //on recieving backend
 console.log("Received this obj",obj); 
 ParsedData=obj;
var x = d3.scale.linear()
    .domain([-5, (30 )]) // changes range of values for x axis
    .range([0, width]);
var y = d3.scale.linear()
    .domain([-5, 30 ]) // changes range of values for y axis
    .range([height, 0]);
console.log("QQQ",ParsedData);
if(ParsedData.Node!=0)
{
 var shape1=document.getElementById(idtochange); 
  d3.select(shape1).attr("cx",x(ParsedData.Column1))
.attr("cy",function(d){
  d.x=(ParsedData.Column1) ;
  d.y= (ParsedData.Column2);
  console.log("Updated",d.x,d.y);
  return y(ParsedData.Column2)})
.attr("r",function(d){return 10;})
.style('fill', function(d){ d.m1=ParsedData.Column3; return mycolormap(ParsedData.Column3);});

 }
else
{

//CIRCLES= d3.selectAll("circle");


var mycolormap1 = d3.scale.linear().domain([0 ,300]).range(["red", "green"]);
   var m1min=0,m1max=300,f=0;

d3.selectAll("circle").each(function(d,i)
{  /*
  console.log(d.m1);
  d.m1=(parseInt(d.m1)+1000).toString();
  console.log(d.m1);*/
 
  BackObj={node:parseInt(d.node),Col:parseInt(d.col1),Column1:parseFloat(d.x),Column2:parseFloat(d.y),Column3:parseFloat(d.m1),Column4:parseFloat(d.m2)};//,x1:parseFloat(BScord[0].x),y1:parseFloat(BScord[0].y),x2:parseFloat(BScord[1].x),y2:parseFloat(BScord[1].y)};//Creating object to send to backend

$.post("http://localhost:8080/update",JSON.stringify(BackObj),function(obj){
   console.log("BASESTATION Received this obj",obj); 
 ParsedData=obj;
 if(ParsedData.Node!=0)
  {
    if(f==0)
    {
      f=1;
      m1min=ParsedData.Column3;
      m1max=ParsedData.Column3;
      d.m1=ParsedData.Column3;
    }
    else
    {
   d.m1=ParsedData.Column3;
    if(m1min > ParsedData.Column3)
      m1min = ParsedData.Column3;
    if(m1max < ParsedData.Column3)
      m1max = ParsedData.Column3;
    }//console.log("ASQ",Math.min.apply(null,[d.m1]));
  }
},"json");//getting from server
});
//var max = d3.selectAll("circle").max(function(d) { return d.m1; });
console.log("AAAAAAAAA");
console.log(m1min);
console.log(m1max);
//m1min and m1max are not updating!!
var mycolormap1 = d3.scale.linear().domain([m1min ,m1max]).range(["red", "green"]);
window.alert();//for sync async error
//d3.selectAll("circle").maximum
//d3.max(d3.selectAll("circle").)
d3.selectAll("circle").style("fill",function(d,i) {if(d.node!=0) return mycolormap1(d.m1); else return "blue"}); 
//console.log(CIRCLES);

//BScord[0].x -> x cord of BS1
/*
  d3.select(circles).attr("cx",x(ParsedData.Column1))
.attr("cy",function(d){
  return y(ParsedData.Column2)})
.attr("r",function(d){return 30;})
.style('fill', function(d){ return mycolormap(ParsedData.Column3);});
*/
   }

}

function loadMe(){
// d3.text("testfile5.csv", fillData);
   SetSize();  

}
 

function dragstarted1(d) {
  d3.event.sourceEvent.stopPropagation();
  d3.select(this).classed("dragging", true);
  console.log(d,d3.event);
var x = d3.scale.linear()
    .domain([-5, (30 )]) // changes range of values for x axis
    .range([0, width]);
var y = d3.scale.linear()
    .domain([-5, 30 ]) // changes range of values for y axis
    .range([height, 0]);
d.x=x.invert(d3.event.sourceEvent.offsetX);
d.y=y.invert(d3.event.sourceEvent.offsetY);
console.log(d3.event);
 d3.select(this).attr("x", x(d.x)).attr("y", y(d.y));
}
function dragged1(d) {
 
  //  d.x=d3.event.sourceEvent.offsetX;
//d.y=d3.event.sourceEvent.offsetY;

d.x=x.invert(d3.event.sourceEvent.offsetX);
d.y=y.invert(d3.event.sourceEvent.offsetY);

//d.x=d3.event.sourceEvent.clientX;//try putting -35 here
//d.y=d3.event.sourceEvent.clientY;
 console.log(d3.event.sourceEvent);
 d3.select(this).attr("x", x(d.x)).attr("y", y(d.y));
 // d3.select(this).attr("cx", d[0] = d3.event.sourceEvent.x)
               //.attr("cy", d[1] = d3.event.sourceEvent.y);
// d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
     //  d.x += d3.event.dx;
      //      d.y += d3.event.dy;
            // d3.select(this).attr("transform", function(d,i){
            //     return "translate(" + [d3.event.dx,d3.event.dy ] + ")"});
}
function dragended1(d) {
     console.log(d,"ended ",d3.event,this);
//d.x=d3.event.sourceEvent.offsetX;
//d.y=d3.event.sourceEvent.offsetY;
 //d.x=d3.event.sourceEvent.screenX-23;
//d.y=d3.event.sourceEvent.screenY+26;
 //d3.select(this).attr("cx", d.x).attr("cy", d.y);
 d3.select(this).classed("dragging", false);
  var x = d3.scale.linear()
    .domain([-5, (30 )]) // changes range of values for x axis
    .range([0, width]);
var y = d3.scale.linear()
    .domain([-5, 30 ]) // changes range of values for y axis
    .range([height, 0]);
console.log('Am I at ',d.x,d.y) ;
//  console.log('But actually at',d.x,d.y,x(d.x),y(d.y));
//Backend Part here
BackObj={node:parseInt(d.node),Col:parseInt(d.col1),Column1:parseFloat(d.x),Column2:parseFloat(d.y),Column3:parseFloat(d.m1),Column4:parseFloat(d.m2)};//,x1:parseFloat(BScord[0].x),y1:parseFloat(BScord[0].y),x2:parseFloat(BScord[1].x),y2:parseFloat(BScord[1].y)};//Creating object to send to backend
               if(d.node==0)
                  { idtochange = "BaseStation "+d.col1;
                   BScord[d.col1].x= d.x;
                   BScord[d.col1].y= d.y;
                 }
              else
                  idtochange = "ERROR";
//window.alert(idtochange);

$.post("http://localhost:8080/update",JSON.stringify(BackObj),onsuccess,"json");//getting from server
             
}

function fillData(text){ 
   console.log("Read this ",text);
  var data = d3.csv.parseRows(text).map(function(row) {
  return row.map(function(value) {
  return +value;    //to convert text to numbers
  });
  });
  console.log(data);
  table=data;   //Taking data from respective rows
  table1=data;
    col1=table[0];
  node=table[1]
    x1=table[2];   
    y1=table[3];
    m1=table[4];
    m2=table[5];
 }
loadMe();


var data = [];


(function() {

window.onload = function() {
    initialize();
};

var size =  1000/Math.sqrt(3), // hexagon size
    radius = 30, // number of hexagons in a row
    tilted = false; // true is horizontal alignment

var w = 4000, // width
    h = 0, // height,these two parameters are the ones to shift the hexagons
    padding = 50;

var translate = [0, 0];
 

function initialize() {
  
  /*  svg = d3.select('body')
        .append('svg:svg')
        .attr('width', w)
        .attr('height', h)
        .attr('pointer-events', 'all'); //*/

    // binding events over 'svg' only
   /* svg.on('mousedown', mouseDrag)
        .on('mousewheel', mouseScroll) // webkit
        .on('DOMMouseScroll', mouseScroll); // firefox
      */  
        
    tooltip = d3.select('body')
        .append('div')
        .classed('tooltip', true);

    fillMap();
    position();
    render();
}

function fillMap() {
    var id = 0,
        limit1 = 0,
        limit2 = radius;
    for (var j = -radius; j <= radius; j++) {
        var i = limit1;
        while (i <= limit2) {
          
            data.push({
                id: id++,
                coordinates: [i, j],

                type: 'regular',
               // resource: Math.random() < .005
            });
            i++;
        }
        if (j < 0) {
            limit1--;
        } else {
            limit2--;
        }
    }

}

function position() {
    // http://goo.gl/8djhT
    //Note that stepX:stepY:offset ratio should be const
    var stepX = 1000,// Math.sqrt(3) * size / 2,
        stepY =  500*Math.sqrt(3),//size * 3 / 4 ,
        offset = 500//size / Math.sqrt(3) * 3 / 4
    data.map(function(d) {
        var i = d.coordinates[0],
            j = d.coordinates[1],
              x = stepX * i + (offset * j ) + w / 2 ,
              y = stepY * j  + h / 2;
        d.centroid = [Math.round(x * 1e2) / 1e2, Math.round(y * 1e2) / 1e2]; //centre of hexagon
        d.visible = 1;//visible everywhere
    });
}

function render() {
    renderMap();
}

function renderMap() {
    var grid = svgContainer.selectAll('polygon.tile')
        .data(getVisibleData(), function(d) { return d.id; });

    grid.enter()
        .sort(function(a, b) { return a.id - b.id; })
        .append('polygon')
        .classed('tile', true)
        .attr('points', function(d) {
            return hex(d.centroid, size, tilted).join(' '); //creates hexagon
        }) .style("pointer-events", "none").attr("transform", "translate(0," + 0 + ")");
 
 var x = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
var y = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//400 is height value defined in SetSize()

  grid.enter()
  .sort(function(a, b) { return a.id - b.id; })
  .append("circle")
   .attr("cx",function(d){ return x(d.centroid[0]); })
  .attr("cy",function(d){ return y(d.centroid[1]);})
  .attr("r", (40)) //radius of 200=40*5 m //linear scale of 5
  .style("fill","none")
  .style("stroke","blue")
  .on('mousewheel', mouseScroll) // webkit
  .on('DOMMouseScroll', mouseScroll); // firefox



        /*
        .on('mouseover', mouseOver) 
        .on('mousemove', mouseMove)
        .on('mouseout', mouseOut)
        .on('mousedown', click);*/
    
    grid.exit().remove();
}
// d3 mouse events
function mouseOver(d, i) { //tooltip to be used for circles 
    d3.select(this).classed('over', true);
    tooltip.text(d.id+ ' (' + d.coordinates + ')  ' + d.lastSelected    )
        .classed('visible', true);
}

function mouseMove(d, i) {
    tooltip.style('top', (d3.event.pageY - 20) + 'px')
        .style('left', (d3.event.pageX + 20) + 'px');
}

function mouseOut(d, i) {
    d3.select(this).classed('over', false);
    tooltip.classed('visible', false);
}

function click(d, i) { // on mouse click ,to be used for circles to show SINR profile ,modify it 
    var element = d3.select(this),
        selected = element.classed('selected');
        
        element.classed('selected', !selected);
        d.type = selected ? 'regular' : 'selected';
        d.lastSelected = +d3.event.timeStamp;
        
        tooltip.text(d.id + ' (' + d.coordinates + ') / ' + d.lastSelected);
}
// Custom drag behavior (replacing 'zoom')
function mouseDrag() {
    var m0 = d3.svg.mouse(this),
        that = this,
        previousMove = [0, 0];
    
    d3.select('body').on('mousemove', function() {
        var m1 = d3.svg.mouse(that),
            shift = d3.event.shiftKey,
            ctrl = d3.event.ctrlKey,
            alt = d3.event.altKey,
            x = ctrl ? 0 : m1[0] - m0[0] - previousMove[0],
            y = shift ? 0 : m1[1] - m0[1] - previousMove[1];
        
        move(x, y);
        previousMove[0] += x;
        previousMove[1] += y;
    });
    
    d3.select('body').on('mouseup', function() {
        d3.select('body')
            .on('mousemove', null)
            .on('mouseup', null);
    });
    
    d3.event.preventDefault();
}
//

function move(x, y) {
    translate[0] += x;
    translate[1] += y;

    moveMap();
}

function moveMap() {
    var dx = translate[0],
        dy = translate[1];

    // Update data
    data.filter(function(d) {
        var x = d.centroid[0] + dx,
            y = d.centroid[1] + dy;
        return d.visible && outbounds(x, y);
    }).map(function(d) {
        d.visible = false;
        return d;
    });
    
    data.filter(function(d) {
        var x = d.centroid[0] + dx,
            y = d.centroid[1] + dy;
        return !d.visible && !outbounds(x, y);
    }).map(function(d) {
        d.visible = true;
        return d;
    });
    //
    
    renderMap();
    
    svg.selectAll('.tile')
        .attr('transform', 'translate(' + [dx, dy] + ')');
}

function outbounds(x, y) {
    return x < padding || x > w - padding || y < padding || y > h - padding;
}

function removeAll() {
    svg.selectAll('.tile').remove();
}

function hex(centroid) {
    var a = 1000/Math.sqrt(3),//size / 2, 
        b = 500,//(Math.sqrt(3) * a) / 2,
        x = centroid[0],
        y = centroid[1];
    var x1 = d3.scale.linear()
    .domain([-2200, (2300 )]) // changes range of values for x axis
    .range([0, 900]); //900 is width value which is defined in Setsize()
  var y1 = d3.scale.linear()
    .domain([-2200, 2300 ]) // changes range of values for y axis
    .range([900, 0]);//400 is height value defined in SetSize()
    //return  [[x - b, y - a / 2], [x - b, y + a / 2], [x, y + a], [x + b, y + a / 2], [x + b, y - a / 2], [x, y - a]];
        return [[x1(x - b),y1(y - a / 2)], [x1(x - b), y1(y + a/2)], [x1(x), y1(y + a)], [x1(x + b), y1(y + a / 2)], [x1(x + b), y1(y - a / 2)], [x1(x),y1(y - a)]];
}



function mouseScroll(d, i) {
    var e = d3.event,
        delta = e.wheelDelta ? e.wheelDelta : e.detail ? -e.detail : 0;
    if (delta > 0) {
        scrollUp();
    } else {
        scrollDown();
    }
    d3.event.preventDefault();
}
//

function scrollDown() {
    if (size > 20) {
        zoom(-20); // zoom out
    }
}

function scrollUp() {
    if (size < 80) {
        zoom(80); // zoom in
    }
}

function zoom(amount) {
    var proportion = (size + amount) / size,
        dx = translate[0] * proportion - translate[0],
        dy = translate[1] * proportion - translate[1];
    size += amount;
    removeAll();
    position();
    move(dx, dy);
}

function getVisibleData() { 
    return data.filter(function(d) { return d.visible; });
}

})();

    </script>

  </body>
</html>